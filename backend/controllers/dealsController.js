// ============================================================
// DEALS CONTROLLER
// Business logic for deal management
// ============================================================

const { query } = require('../config/database');
const { AppError } = require('../middleware/errorHandler');
const Joi = require('joi');

/**
 * Validation schema for deal creation
 */
const createDealSchema = Joi.object({
  borrower_id: Joi.string().uuid().required(),
  deal_name: Joi.string().min(3).max(255).required(),
  loan_amount: Joi.number().positive().required(),
  asset_type: Joi.string().valid('multifamily', 'retail', 'office', 'industrial', 'mhp', 'mixed_use', 'land').required(),
  property_address_line1: Joi.string().max(255).optional(),
  property_city: Joi.string().max(100).optional(),
  property_state: Joi.string().max(50).optional(),
  property_zip_code: Joi.string().max(20).optional(),
  loan_purpose: Joi.string().valid('purchase', 'refinance', 'cash_out', 'construction').optional(),
  loan_type: Joi.string().valid('bridge', 'term', 'construction', 'perm').optional(),
  requested_ltv: Joi.number().min(0).max(100).optional(),
  requested_rate: Joi.number().min(0).max(30).optional(),
  requested_term_months: Joi.number().integer().positive().optional(),
  notes: Joi.string().optional()
});

/**
 * POST /api/deals
 * Create a new deal
 */
exports.createDeal = async (req, res, next) => {
  try {
    // Validate request body
    const { error, value } = createDealSchema.validate(req.body);
    if (error) {
      throw new AppError(error.details[0].message, 400, 'VALIDATION_ERROR');
    }

    const {
      borrower_id,
      deal_name,
      loan_amount,
      asset_type,
      property_address_line1,
      property_city,
      property_state,
      property_zip_code,
      loan_purpose,
      loan_type,
      requested_ltv,
      requested_rate,
      requested_term_months,
      notes
    } = value;

    // Verify borrower exists and belongs to user's org
    const borrowerCheck = await query(
      'SELECT id FROM borrowers WHERE id = $1 AND org_id = $2',
      [borrower_id, req.user.org_id]
    );

    if (borrowerCheck.rows.length === 0) {
      throw new AppError('Borrower not found or does not belong to your organization', 404, 'BORROWER_NOT_FOUND');
    }

    // Insert new deal (deal_number will be auto-generated by trigger)
    const result = await query(`
      INSERT INTO deals (
        org_id,
        borrower_id,
        deal_name,
        loan_amount,
        asset_type,
        property_address_line1,
        property_city,
        property_state,
        property_zip_code,
        loan_purpose,
        loan_type,
        requested_ltv,
        requested_rate,
        requested_term_months,
        status,
        stage,
        broker_id,
        created_by,
        notes
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19)
      RETURNING *
    `, [
      req.user.org_id,
      borrower_id,
      deal_name,
      loan_amount,
      asset_type,
      property_address_line1 || null,
      property_city || null,
      property_state || null,
      property_zip_code || null,
      loan_purpose || null,
      loan_type || null,
      requested_ltv || null,
      requested_rate || null,
      requested_term_months || null,
      'intake',
      'lead',
      req.user.id, // broker_id
      req.user.id, // created_by
      notes || null
    ]);

    const deal = result.rows[0];

    res.status(201).json({
      success: true,
      message: 'Deal created successfully',
      data: deal
    });
  } catch (error) {
    next(error);
  }
};

/**
 * GET /api/deals/:id
 * Get a single deal by ID
 */
exports.getDealById = async (req, res, next) => {
  try {
    const { id } = req.params;

    // Query deal with related data (RLS will enforce org_id filtering)
    const result = await query(`
      SELECT 
        d.*,
        b.entity_name as borrower_name,
        b.entity_type as borrower_entity_type,
        u_broker.email as broker_email,
        u_broker.first_name as broker_first_name,
        u_broker.last_name as broker_last_name,
        u_assigned.email as assigned_to_email,
        u_assigned.first_name as assigned_to_first_name,
        u_assigned.last_name as assigned_to_last_name
      FROM deals d
      LEFT JOIN borrowers b ON d.borrower_id = b.id
      LEFT JOIN users u_broker ON d.broker_id = u_broker.id
      LEFT JOIN users u_assigned ON d.assigned_to = u_assigned.id
      WHERE d.id = $1 AND d.org_id = $2
    `, [id, req.user.org_id]);

    if (result.rows.length === 0) {
      throw new AppError('Deal not found', 404, 'DEAL_NOT_FOUND');
    }

    res.json({
      success: true,
      data: result.rows[0]
    });
  } catch (error) {
    next(error);
  }
};

/**
 * GET /api/deals
 * List all deals with pagination and filters
 */
exports.listDeals = async (req, res, next) => {
  try {
    const {
      page = 1,
      limit = 20,
      status,
      asset_type,
      assigned_to
    } = req.query;

    const offset = (page - 1) * limit;

    // Build WHERE clause dynamically
    let whereConditions = ['d.org_id = $1'];
    let queryParams = [req.user.org_id];
    let paramIndex = 2;

    if (status) {
      whereConditions.push(`d.status = $${paramIndex}`);
      queryParams.push(status);
      paramIndex++;
    }

    if (asset_type) {
      whereConditions.push(`d.asset_type = $${paramIndex}`);
      queryParams.push(asset_type);
      paramIndex++;
    }

    if (assigned_to) {
      whereConditions.push(`d.assigned_to = $${paramIndex}`);
      queryParams.push(assigned_to);
      paramIndex++;
    }

    const whereClause = whereConditions.join(' AND ');

    // Get total count
    const countResult = await query(
      `SELECT COUNT(*) FROM deals d WHERE ${whereClause}`,
      queryParams
    );
    const totalCount = parseInt(countResult.rows[0].count);

    // Get paginated results
    const result = await query(`
      SELECT 
        d.*,
        b.entity_name as borrower_name,
        u_broker.email as broker_email,
        u_assigned.email as assigned_to_email
      FROM deals d
      LEFT JOIN borrowers b ON d.borrower_id = b.id
      LEFT JOIN users u_broker ON d.broker_id = u_broker.id
      LEFT JOIN users u_assigned ON d.assigned_to = u_assigned.id
      WHERE ${whereClause}
      ORDER BY d.created_at DESC
      LIMIT $${paramIndex} OFFSET $${paramIndex + 1}
    `, [...queryParams, limit, offset]);

    res.json({
      success: true,
      data: result.rows,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: totalCount,
        totalPages: Math.ceil(totalCount / limit)
      }
    });
  } catch (error) {
    next(error);
  }
};

/**
 * PUT /api/deals/:id
 * Update a deal
 */
exports.updateDeal = async (req, res, next) => {
  try {
    const { id } = req.params;
    const updates = req.body;

    // Verify deal exists and belongs to user's org
    const dealCheck = await query(
      'SELECT id FROM deals WHERE id = $1 AND org_id = $2',
      [id, req.user.org_id]
    );

    if (dealCheck.rows.length === 0) {
      throw new AppError('Deal not found', 404, 'DEAL_NOT_FOUND');
    }

    // Build UPDATE query dynamically
    const allowedFields = [
      'deal_name', 'loan_amount', 'asset_type', 'status', 'stage',
      'property_address_line1', 'property_city', 'property_state',
      'assigned_to', 'notes', 'expected_close_date'
    ];

    const updateFields = [];
    const updateValues = [];
    let paramIndex = 1;

    for (const [key, value] of Object.entries(updates)) {
      if (allowedFields.includes(key)) {
        updateFields.push(`${key} = $${paramIndex}`);
        updateValues.push(value);
        paramIndex++;
      }
    }

    if (updateFields.length === 0) {
      throw new AppError('No valid fields to update', 400, 'NO_UPDATES');
    }

    // Add updated_at
    updateFields.push(`updated_at = NOW()`);

    // Execute update
    const result = await query(`
      UPDATE deals
      SET ${updateFields.join(', ')}
      WHERE id = $${paramIndex} AND org_id = $${paramIndex + 1}
      RETURNING *
    `, [...updateValues, id, req.user.org_id]);

    res.json({
      success: true,
      message: 'Deal updated successfully',
      data: result.rows[0]
    });
  } catch (error) {
    next(error);
  }
};

/**
 * DELETE /api/deals/:id
 * Delete a deal (admin only)
 */
exports.deleteDeal = async (req, res, next) => {
  try {
    const { id } = req.params;

    const result = await query(
      'DELETE FROM deals WHERE id = $1 AND org_id = $2 RETURNING id',
      [id, req.user.org_id]
    );

    if (result.rows.length === 0) {
      throw new AppError('Deal not found', 404, 'DEAL_NOT_FOUND');
    }

    res.json({
      success: true,
      message: 'Deal deleted successfully'
    });
  } catch (error) {
    next(error);
  }
};
